Title: Notes on setting up a Gitlab Runner on Azure
Date: 2019-02-22
Category: DevOps
Tags: azure, devops, gitlab, docker, ci, tests
Slug: notes-on-setting-up-a-gitlab-runner-on-azure
Authors: François Leblanc
Summary: In this post, we dive into setting up a Gitlab runner instance on Azure cloud. We'll use it for Gitlab CI/CD, to trigger a runner for building, testing and deploying your code.

In my current position, I work for the CDO at Environment and Climate Change Canada. We're fortunate to use a Gitlab CE instance called GCCode, accessible to public servants from all federal departments and agencies. It's great to work in teams, sharing and collaborating on code projects across government, and elevates the potential for code reuse throughout the government. Of course, only unprotected codebases are hosted there &mdash; you're not going to find the Department of Defence's stuff in there! A word of warning: it's only accessible on the Government of Canada's internal network, so you won't be able to access it if you're looking for it.

I have to say that Gitlab comes with an amazing array of features, even for its Community Edition. It boggles the mind, really! To me, the single most useful feature on there is the Gitlab CI/CD feature. The acronym, of course, stands for continuous integration / continuous deployment &mdash; that is, every time you push code to Gitlab, it can automatically trigger a small machine to build your code, run tests, and deploy the new version of your project.

That means you can publish your website to `test` or `prod`, automatically fail merge requests if the tests don't pass, and pretty much anything your little mind can come up with. Not that the concept is whimsical or fancy in any way: it's the standard for most, if not all serious open source projects out there.

In this case, the GCCode instance does not have provisions for Gitlab runners (or Pages), so teams need to set up their own. Many departments will use local servers to achieve this, however our directorate does not have any.

Instead, we'll set up Gitlab runners on Microsoft's cloud &mdash; Azure &mdash; so that we can start using them. Given our current (very small) testing compute load, cost estimation math puts this to around 50$/mo.

## Game Plan
We'll set up a single, cheap virtual machine (VM) that will always be running. You could scale this up to spawn other VMs as load becomes bigger, but for now this will suit our needs.  When testing time becomes an issue, we can always come back to it and set up autoscaling, which will spin up Low Priority VMs as and when required. But that's another blog post ð.

1. Create the spawner resource
2. Install dependencies
3. Setup the runner locally
4. Register the runner back on Gitlab

## Creating the Azure resource

![Azure Resource Creation Pane](img/azure_gitlab_runner_resource.png)

In the resource creation pane, navigate to create a new Ubuntu VM. I've selected the cheapest option in my region. Notes:

* Pick a region closest to where your Gitlab instance is located
* No infrastructure redundancy
* The image version doesn't matter here, but easier to install if your Linux distribution is Debian-based
* Be sure to open ports 443 for HTTPS, and 22 for SSH

## Install dependencies
:w


## Setup the runner locally


## Register the runner back on Gitlab



